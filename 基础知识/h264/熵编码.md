## 指数哥伦布编码
- ue(v):无符号指数哥伦布编码
- se(v)：有符号指数哥伦布编码
- me(v)：映射指数哥伦布编码
- te(v)：阶段指数哥伦布编码

### ue(v)
- 要编码的数+1,x=v+1
- 转换成二进制，计算二进制位数(b)
- 二进制前面补（b-1）个0

```sh
ue(4){
    x=4+1=5
    bin(x)=101
    5 有3位，补充2个0

    00101
}

```
- 解码过程：<font color=red>0个个数+1是后面 数据的长度</font>
- 对后面数据 -1

### se(v)

- 要编码的数组转二进制,bin(v)
- v如果是正，末尾追加1，负数，末尾追加0
- 计算二进制长度b
- 二进制前面补（b-1）个0

```sh
se(-5){
    bin(5)=101
    1010  #末尾追加0
    b=4,补3个0
    0001010
}
```
- 解码过程：<font color=red>0个个数是后面 数据的长度</font>
- 再读取一位表示符号位

### me(v)
- 指数哥伦布的特点是小数编码后长度短，大数编码后长度长，me是为了解决这个问题。
- 映射指数哥伦布编码存在一个码表，使用和ue一样的算法，解码出来的数值表示这个码表的索引

### te(v)
- 当编码的v>1时候，算法同ue(v)
- v=0,v=1的时候，下一个bit取反
```sh
te(0)->11

te(1)->10

te(2)->ue(2)
```